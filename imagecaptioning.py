# -*- coding: utf-8 -*-
"""ImageCaptioning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18d6fijGmhMC9CUePKsjGgPc9VbLRJlie

# Neural Image Caption Generation Using Pre-trained ResNet-101 and LSTM with Attention

In this notebook, I train an encoder-decoder model with attention mechanisms for the task of image captioning. The model is trained on the MS COCO dataset, utilizing Karpathy's split, which includes approximately 113,000 high-quality images in the training set.

The encoder is a ResNet-101 convolutional neural network (CNN) pre-trained on large image datasets. While I did not fine-tune the CNN during training, the option to do so is available in the code below. The primary role of the CNN is to generate encoded representations of the image, extracting key features that are subsequently passed into the decoder for further processing.

The LSTM variant of recurrent neural networks (RNN) is chosen as the decoder. The attention mechanism is incorporated while decoding to determine how much attention should be placed on each region in the encoded image. This helps address the main issue with RNNs: their difficulty in handling long sequences of input, especially in cases where important information is spread out across a large number of pixels in the image.

The ADAM optimizer is used to update the modelâ€™s weights, offering robust optimization by combining the benefits of adaptive learning rates and momentum. I utilize a learning rate scheduler to dynamically adjust the learning rate during training, helping to achieve more efficient convergence and avoid overshooting minima.


The model I trained reached a top-5 validation accuracy of 76.57% and top-10 validation accuracy of 83.80%. An example image with a generated caption can be seen at the bottom of the notebook.

![image.png](data:image/png;base64,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)

Xu et al., 2016

## Import Libraries
"""

import os
import json
from collections import Counter
import random
from google.colab import drive

import matplotlib.pyplot as plt
from PIL import Image
import numpy as np
import cv2
from tqdm.notebook import tqdm

import torch
from torch.utils.data import Dataset, DataLoader
import torch.optim as optim
import torch.nn as nn
import torch.nn.functional as F
import torchvision.models as models
from torch.nn.utils.rnn import pack_padded_sequence
from nltk.translate.bleu_score import corpus_bleu
import torch.backends.cudnn as cudnn
import torchvision.transforms as transforms
import skimage.transform


import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="nltk.translate.bleu_score")

from google.colab import drive
drive.mount('/content/drive')

"""## Download Data"""

!wget http://images.cocodataset.org/zips/train2014.zip
!unzip 'train2014.zip'
!rm -r 'train2014.zip'

!wget http://images.cocodataset.org/zips/val2014.zip
!unzip 'val2014.zip'
!rm -r 'val2014.zip'

!wget https://cs.stanford.edu/people/karpathy/deepimagesent/caption_datasets.zip
!unzip 'caption_datasets.zip'
!rm -r 'caption_datasets.zip'

print(f"# Training images: {len(os.listdir('train2014'))}")
print(f"# Val images: {len(os.listdir('val2014'))}")

with open('dataset_coco.json', 'r') as f:
    data = json.load(f)

"""## Pre-Process Text"""

image_folder = '/content'
min_word_freq = 5           # words occuring less than this threshold will be labelled as <unk>
captions_per_image = 5      # number of captions per image
max_len = 100

word_freq = Counter()       # Counter object to find the freq of each word

for image in data["images"]:
  for sentence in image["sentences"]:
    word_freq.update((word for word in sentence["tokens"]))

# Most frequent words
word_freq.most_common(10)

# Num of words
len(word_freq.keys())

# Num of words that appear more than 5 times
words = [word for word in word_freq.keys() if word_freq[word] > min_word_freq]
len(words)

# Create word/id maps
word2id = {word:id for id, word in enumerate(words, 2)}
word2id['<pad>'] = 0
word2id['<start>'] = 1
word2id['<unk>'] = len(word2id) + 1
word2id['<end>'] = len(word2id) + 1

id2word = {id:word for word, id in word2id.items()}

# Num images in each split
c = Counter()
for img in data['images']:
  c[img['split']] +=1
c

# Grab image paths, captions, and caption lengths

train_image_paths = []
train_image_captions = []
train_caption_lens = []

val_image_paths = []
val_image_captions = []
val_caption_lens = []

test_image_paths = []
test_image_captions = []
test_caption_lens = []


for image in data["images"]:
  captions = []

  # only include captions with < 100 tokens
  for sentence in image["sentences"]:
    if len(sentence['tokens']) <= max_len:
      captions.append(sentence['tokens'])

  # handling images with < or > 5 captions
  if len(captions) < captions_per_image:
      captions += [random.choice(captions) for _ in range(captions_per_image - len(captions))]
  else:
    captions = random.sample(captions, k=captions_per_image)

  assert len(captions) == captions_per_image

  encoded = []
  caption_lens = []

  # encode, pad captions
  for idx, caption in enumerate(captions):
    enc = [word2id['<start>']] + [word2id.get(word, word2id['<unk>']) for word in caption] + [word2id['<end>']] + [word2id['<pad>']] * (max_len - len(caption))
    encoded.append(enc)

    caption_len = len(caption) + 2
    caption_lens.append(caption_len)

  path = os.path.join(image_folder, image['filepath'], image['filename'])

  #store image paths, captions, and caption lengths
  if image['split'] in {"train", "restval"}:
    train_image_paths.append(path)
    train_image_captions.append(encoded)
    train_caption_lens.append(caption_lens)

  elif image['split'] == "val":
    val_image_paths.append(path)
    val_image_captions.append(encoded)
    val_caption_lens.append(caption_lens)

  elif image['split'] == "test":
    test_image_paths.append(path)
    test_image_captions.append(encoded)
    test_caption_lens.append(caption_lens)


assert len(train_image_paths) == len(train_image_captions)
assert len(val_image_paths) == len(val_image_captions)
assert len(test_image_paths) == len(test_image_captions)

# Connect to GPU
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
device

"""## Creating Dataset"""

len(train_image_paths)

len(train_image_captions[0])

train_caption_lens[0]

class CaptionDataset(Dataset):
    def __init__(self, image_paths, captions, caption_lens, split, captions_per_image = 5):
        self.image_paths = image_paths
        self.captions = captions
        self.caption_lens = caption_lens
        self.split = split
        self.captions_per_image = captions_per_image

        assert self.split in {'train', 'val', 'test'}

    def __len__(self):
        return len(self.image_paths) * self.captions_per_image

    def __getitem__(self, idx):
        img = Image.open(self.image_paths[idx // self.captions_per_image]).convert('RGB')
        img = np.array(img)
        img = cv2.resize(img, (256,256))
        img = np.transpose(img, (2,0,1))

        assert img.shape == (3, 256, 256)
        assert np.max(img) <= 255

        img = torch.FloatTensor(img / 255.)
        caption = torch.LongTensor(self.captions[idx // self.captions_per_image][idx % self.captions_per_image])
        caption_len = torch.LongTensor([self.caption_lens[idx // self.captions_per_image][idx % self.captions_per_image]])

        if self.split == 'train':
            return img, caption, caption_len
        else:
            all_captions = torch.LongTensor(self.captions[idx // self.captions_per_image])
            return img, caption, caption_len, all_captions

train_dataset = CaptionDataset(train_image_paths, train_image_captions, train_caption_lens, 'train')
val_dataset = CaptionDataset(val_image_paths, val_image_captions, val_caption_lens, 'val')
test_dataset = CaptionDataset(test_image_paths, test_image_captions, test_caption_lens, 'test')

print(f"TRAINING:   {len(train_image_paths)} images, {len(train_dataset)} captions")
print(f"VALIDATION: {len(val_image_paths)}   images, {len(val_dataset)}  captions")
print(f"TEST:       {len(test_image_paths)}   images, {len(test_dataset)}  captions")

"""## Data Examples"""

def decode_caption(encoded_caption):
    decoded = [id2word[id.item()] for id in encoded_caption if id2word[id.item()] not in ["<start>", "<end>", "<unk>", "<pad>"]]
    return " ".join(decoded)

def display_example(img, caption, all = None):
    if all is not None:
        for c in all:
            print(decode_caption(c))
    else:
        print(decode_caption(caption))

    img = img.numpy().transpose(1,2,0)
    plt.imshow(img)
    plt.axis('off')

img, caption, caption_len = train_dataset[24909]
display_example(img, caption)

img, caption, caption_len, all = val_dataset[24999]
display_example(img, caption, all)

"""## Create DataLoaders"""

train_dataloader = DataLoader(train_dataset, batch_size = 32, shuffle = True, num_workers=8, pin_memory=True)
val_dataloader = DataLoader(val_dataset, batch_size = 32, shuffle = True, num_workers=8, pin_memory=True)
test_dataloader = DataLoader(test_dataset, batch_size = 32, shuffle = True, num_workers=8, pin_memory=True)

images, captions, caption_lens = next(iter(train_dataloader))
print(images.shape)
print(captions.shape)
print(caption_lens.shape)

images, captions, caption_lens, all_captions = next(iter(val_dataloader))
print(images.shape)
print(captions.shape)
print(caption_lens.shape)
print(all_captions.shape)

images, captions, caption_lens, all_captions = next(iter(test_dataloader))
print(images.shape)
print(captions.shape)
print(caption_lens.shape)
print(all_captions.shape)

"""## Model Architecture"""

class Encoder(nn.Module):
    def __init__(self, enc_image_size = 14):
        super(Encoder, self).__init__()

        self.enc_image_size = enc_image_size

        # Load in resnet
        # resnet = models.resnet50(weights="IMAGENET1K_V2")
        resnet = models.resnet101(weights='DEFAULT')

        # Remove final pooling and FC layer
        modules = list(resnet.children())[:-2]

        self.encoder = nn.Sequential(*modules)
        self.adaptive_pool = nn.AdaptiveAvgPool2d((enc_image_size, enc_image_size))

    def fine_tune(self):
        self.encoder.train()
        pass

    def forward(self, batch): # Takes in tensor of size (32, 3, 256, 256) = (batch size, # channels, height, width)
        out = self.encoder(batch)                              # (32, 2048, 8, 8)
        out = self.adaptive_pool(out)                           # (32, 2048, 14, 14)
        out = out.view(out.size(0), out.size(1), -1)            # (32, 2048, 196)
        out = out.permute(0,2,1)                                # (32, 196, 2048)
        return out            # Outputs tensor of size (32, 196, 2048) = (batch size, seq_length, seq_dim)


# batch_size = 32
# num_pixels = 196 = seq_len
# encoder_dim = 2048 = seq_dim

# Sanity Check
encoder = Encoder()
test_encoder_out = encoder(images)
test_encoder_out.shape

class Attention(nn.Module):
    def __init__(self, encoder_dim, decoder_dim, attention_dim):
        super(Attention, self).__init__()
        self.encoder_att = nn.Linear(encoder_dim, attention_dim)
        self.decoder_att = nn.Linear(decoder_dim, attention_dim)
        self.full_att = nn.Linear(attention_dim, 1)

    def forward(self, encoder_out, decoder_hidden):
        key = self.encoder_att(encoder_out) # (32, 196, 2048)  to (32, 196, 512)
        query = self.decoder_att(decoder_hidden) # (32, 512) to (32, 512)

        att = self.full_att(F.relu(key + query.unsqueeze(1))) # (32, 196, 1)
        alpha = F.softmax(att, dim = 1) # (32, 196, 1)

        att_weighted_encoding = (encoder_out * alpha).sum(dim = 1) # (32, 2048)
        alpha = alpha.squeeze(2) # (32, 196)

        return att_weighted_encoding, alpha

class Decoder(nn.Module):
    def __init__(self, encoder_dim, decoder_dim, attention_dim, embed_dim, vocab_size, dropout = 0.5):
        super(Decoder, self).__init__()

        self.encoder_dim = encoder_dim
        self.decoder_dim = decoder_dim
        self.attention_dim = attention_dim
        self.embed_dim = embed_dim
        self.vocab_size = vocab_size
        self.dropout = dropout

        self.attention = Attention(encoder_dim, decoder_dim, attention_dim)
        self.embedding = nn.Embedding(vocab_size, embed_dim)
        self.dropout = nn.Dropout(p = dropout)
        self.decode_step = nn.LSTMCell(embed_dim + encoder_dim, decoder_dim, bias=True)
        self.fc = nn.Linear(decoder_dim, vocab_size)

        self.init_h = nn.Linear(encoder_dim, decoder_dim)   # linear layer to find initial hidden state of LSTMCell
        self.init_c = nn.Linear(encoder_dim, decoder_dim)
        self.f_beta = nn.Linear(decoder_dim, encoder_dim)

        self.init_weights()

    def init_weights(self):
        self.embedding.weight.data.uniform_(-0.1, 0.1)
        self.fc.bias.data.fill_(0)
        self.fc.weight.data.uniform_(-0.1, 0.1)

    def init_hidden_state(self, encoder_out):
        mean_encoder_out = encoder_out.mean(dim = 1) # (32, 2048)
        h = self.init_h(mean_encoder_out) # (32, 512)
        c = self.init_c(mean_encoder_out) # (32, 512)
        return h,c

    def forward(self, encoder_out, encoded_captions, caption_lens):
        """
        encoder_out: (32, 196, 2048) - image representations
        encoded_captions: (32, 102) - captions
        caption_lens: (32, 1) - length of each caption
        """
        batch_size = encoder_out.size(0)
        num_pixels = encoder_out.size(1)

        vocab_size = self.vocab_size

        # Sort imgs/caps by decreasing caption length
        caption_lens, sort_idx = caption_lens.squeeze(1).sort(dim=0, descending=True)
        encoder_out = encoder_out[sort_idx]
        encoded_captions = encoded_captions[sort_idx]

        # Embed captions
        embeddings = self.embedding(encoded_captions)   # (32, 102, 512)

        # Initialize states
        h, c = self.init_hidden_state(encoder_out) # (32, 512)

        # Do not decode after <end> token
        decode_lens = (caption_lens-1).tolist()

        # Create empty word prediction scores and alphas
        predictions = torch.zeros(batch_size, max(decode_lens), vocab_size).to(device) # (32, x, vocabsize)
        alphas = torch.zeros(batch_size, max(decode_lens), num_pixels).to(device) # (32, x, 196)

        # At each time step, decode by:
        # Using attention-weighted encoder output (based on decoder's previous hidden state)
        # and previous word

        for t in range(max(decode_lens)):
            # May not need to decode all 32 images at each time step (sentence may be complete)
            batch_size_t = sum([l > t for l in decode_lens])

            # Get attention weighted encodings
            weighted_enc, alpha = self.attention(encoder_out[:batch_size_t], h[:batch_size_t]) # (batch_size_t, 2048)

            # 0-1 scalar of how much weighted encoding should be used
            gate = F.sigmoid(self.f_beta(h[:batch_size_t])) # (batch_size_t, 2048)
            weighted_enc = gate * weighted_enc # (batch_size_t, 2048)

            # Process in LSTM cell using embeddings and weighted encoding to get new hidden state and new cell state
            h, c = self.decode_step(
                torch.cat([embeddings[:batch_size_t, t, :], weighted_enc], dim=1), # (batch_size_t, 2560)
                (h[:batch_size_t], c[:batch_size_t]) # both (batch_size_t, 512)
                )

            # Get word predictions based on new hidden states
            preds =  self.fc(self.dropout(h)) # (batch_size_t, vocab_size)

            # Save predictions and alphas for all time steps
            predictions[:batch_size_t, t, :] = preds
            alphas[:batch_size_t, t, :] = alpha

        return predictions, encoded_captions, decode_lens, alphas, sort_idx

"""Testing Decoder:"""

encoder_dim = 2048
decoder_dim = 512
attention_dim = 512
embed_dim = 512
vocab_size = len(word2id) + 1

decoder = Decoder(encoder_dim, decoder_dim, attention_dim, embed_dim, vocab_size = vocab_size)

images, captions, caption_lens = next(iter(train_dataloader))
encoder = Encoder()
test_encoder_out = encoder(images)
predictions, encoded_captions, decode_lens, alphas, sort_idx = decoder(test_encoder_out, captions, caption_lens)

predictions.shape # (batch_size, #timesteps, vocab_size) # Score/pred for each word at each timestep

encoded_captions.shape

print(len(decode_lens))
print(alphas.shape)
print(sort_idx.shape)

"""## Helper Functions"""

def accuracy(preds, targets, k):
    """
    Top-k accuracy
    If actual word at a given timestamp is in top k predictions, then it is considered correct
    """

    batch_size = targets.size(0)

    _, ind = torch.topk(preds, k, 1, True, True)
    correct = torch.eq(ind, targets.view(-1,1).expand_as(ind))
    correct_total = correct.view(-1).float().sum()
    percent = correct_total.item() * (100.0 / batch_size)

    return percent

def clip_gradient(optimizer, grad_clip):
    for group in optimizer.param_groups:
      for param in group['params']:
          if param.grad is not None:
              param.grad.data.clamp_(-grad_clip, grad_clip)

def save_checkpoint(epoch, epochs_since_improvement, encoder, decoder, encoder_optimizer, decoder_optimizer, bleu4, is_best):
    state = {'epoch': epoch,
             'epochs_since_improvement': epochs_since_improvement,
             'encoder': encoder,
             'decoder': decoder,
             'encoder_optimizer': encoder_optimizer,
             'decoder_optimizer': decoder_optimizer,
             'bleu-4': bleu4,
             'is_best': is_best
             }

    filename = 'checkpoint_' + str(epoch) + '.pth'
    print(f"Saving checkpoint after epoch {str(epoch)}")
    torch.save(state, filename)

    if is_best:
        print('Saving the best model')
        torch.save(state, 'BEST_checkpoint.pth')

"""## Training Functions"""

def train_epoch(loader, encoder, decoder, loss_fn, encoder_optimizer, decoder_optimizer):
    """
    One epoch of training
    """

    encoder.train()
    decoder.train()

    losses = []
    top5_accs = []
    top10_accs = []

    for i, (images, captions, caption_lens) in enumerate(tqdm(train_dataloader, total=len(train_dataloader))):

        # Move batch to GPU
        images = images.to(device)
        captions = captions.to(device)
        caption_lens = caption_lens.to(device)

        # Forward
        encoder_out = encoder(images)
        predictions, encoded_captions, decode_lens, alphas, sort_idx = decoder(encoder_out, captions, caption_lens)

        # Remove start token from targets
        targets = encoded_captions[:, 1:]

        # Remove padding tokens and pack sequences (get rid of timesteps we didn't decode at)
        predictions = pack_padded_sequence(predictions, decode_lens, batch_first=True).data
        targets = pack_padded_sequence(targets, decode_lens, batch_first=True).data

        # Calculate loss - includes a regularization term to maintain "Doubly Stochastic Attention" which:
        # 1. brings all weights sum to 1 at each timestep to have weights behave like probabilities
        # 2. ensures that the attention weights are smoothly distributed across all timesteps and not overly concentrated
        loss = loss_fn(predictions, targets) + alpha_c * ((1. - alphas.sum(dim=1)) ** 2).mean()


        # Backpropagation
        # encoder_optimizer.zero_grad()
        decoder_optimizer.zero_grad()
        loss.backward()

        # Clip gradients
        # clip_gradient(encoder_optimizer, grad_clip)
        clip_gradient(decoder_optimizer, grad_clip)

        # Nudge weights
        # encoder_optimizer.step()
        decoder_optimizer.step()

        # Store metrics
        top5 = accuracy(predictions, targets, 5)
        top5_accs.append(top5)

        top10 = accuracy(predictions, targets, 10)
        top10_accs.append(top10)

        losses.append(loss.item())

    return np.mean(losses), np.mean(top5_accs), np.mean(top10_accs)

def val_epoch(loader, encoder, decoder, loss_fn):
    """
    One epoch of validation
    """

    encoder.eval()
    decoder.eval()

    losses = []
    top5_accs = []
    top10_accs = []

    truth = []
    hypotheses = []

    # Do not need computational graph for inference
    with torch.no_grad():

        for i, (images, captions, caption_lens, all_caps) in enumerate(tqdm(loader, total=len(loader))):

            # Move batch to GPU
            images = images.to(device)
            captions = captions.to(device)
            caption_lens = caption_lens.to(device)

            # Forward
            encoder_out = encoder(images)
            predictions, encoded_captions, decode_lens, alphas, sort_idx = decoder(encoder_out, captions, caption_lens)

            # Remove start token from targets
            targets = encoded_captions[:, 1:]
            predictions_copy = predictions.clone()

            # Remove padding tokens and pack sequences (get rid of timesteps we didn't decode at)
            predictions = pack_padded_sequence(predictions, decode_lens, batch_first=True).data
            targets = pack_padded_sequence(targets, decode_lens, batch_first=True).data

            # Calculate loss
            loss = loss_fn(predictions, targets) + alpha_c * ((1. - alphas.sum(dim=1)) ** 2).mean()

            # Store metrics
            top5 = accuracy(predictions, targets, 5)
            top5_accs.append(top5)

            top10 = accuracy(predictions, targets, 10)
            top10_accs.append(top10)

            losses.append(loss.item())


            # Truth
            all_caps = all_caps[sort_idx.cpu()]
            batch_size = all_caps.size(0)
            for j in range(batch_size):
                image_caps = all_caps[j].tolist()
                image_caps = [[id for id in cap if id not in {word2id['<start>'], word2id['<pad>']}] for cap in image_caps]

                # Each position (image) in the list will be a list of 5 sentences
                truth.append(image_caps)

            # Hypotheses
            _, preds = torch.max(predictions_copy, dim=2) # preds is shape (batch, # timesteps)
            preds = preds.tolist()

            for j, pred in enumerate(preds): # Loop through each image

                seqlen = decode_lens[j]

                # Remove padding
                caps = preds[j][:seqlen]

                # Each position (image) in the list will contain 1 predicted sentence
                hypotheses.append(caps)

            assert len(truth) == len(hypotheses)

            bleu4 = corpus_bleu(truth, hypotheses, weights = (0.25, 0.25, 0.25, 0.25)) # all 4 n-grams given equal weight

    return np.mean(losses), np.mean(top5_accs), np.mean(top10_accs), bleu4

"""## Training Loop and Setup"""

# Parameters
embed_dim = 512
encoder_dim = 2048
decoder_dim = 512
attention_dim = 512
vocab_size = len(word2id) + 1

encoder_lr = 1e-4
decoder_lr = 4e-4

grad_clip = 5.
alpha_c = 1.
best_bleu4 = 0

lr_decay_factor = 0.8
lr_decay_patience = 8

start_epoch = 1
epochs_since_improvement = 0
num_epochs = 10

checkpoint = "BEST_checkpoint.pth" # or "BEST_checkpoint.pth"
cudnn.benchmark = True


# Use checkpoint?
if checkpoint is None:
    encoder = Encoder()
    encoder_optimizer = None

    decoder = Decoder(encoder_dim, decoder_dim, attention_dim, embed_dim, vocab_size)
    decoder_optimizer = optim.Adam(params=filter(lambda p: p.requires_grad, decoder.parameters()), lr=decoder_lr)

else:
    checkpoint = torch.load(checkpoint)

    start_epoch = checkpoint['epoch'] + 1
    epochs_since_improvement = checkpoint['epochs_since_improvement']
    best_bleu4 = checkpoint['bleu-4']

    encoder = checkpoint['encoder']
    encoder_optimizer = None

    decoder = checkpoint['decoder']
    decoder_optimizer = checkpoint['decoder_optimizer']


# Send to GPU
encoder = encoder.to(device)
decoder = decoder.to(device)

# To dynamically adjust learning rate
encoder_lr_scheduler = None
decoder_lr_scheduler = optim.lr_scheduler.ReduceLROnPlateau(decoder_optimizer, mode='max', factor=lr_decay_factor, patience=lr_decay_patience)

# Loss function
loss_fn = nn.CrossEntropyLoss().to(device)

# Loop
for epoch in range(start_epoch, num_epochs + 1):
    print(f"Epoch: {epoch:02d}")

    # Perform one epoch of training
    loss_train, top5acc_train, top10acc_train = train_epoch(train_dataloader, encoder, decoder, loss_fn, encoder_optimizer, decoder_optimizer)

    # Perform one epoch of validation
    loss_val, top5acc_val, top10acc_val, bleu4_val = val_epoch(val_dataloader, encoder, decoder, loss_fn)

    # One step in LR scheduler
    decoder_lr_scheduler.step(bleu4_val)

    # Check for improvement
    is_best = bleu4_val > best_bleu4
    best_bleu4 = max(best_bleu4, bleu4_val)

    if is_best:
        epochs_since_improvement = 0
    else:
        epochs_since_improvement += 1


    # Print results
    print(f"Train Loss: {loss_train:.4f}, Train Top-5 Acc: {top5acc_train:.2f}%, Train Top-10 Acc: {top10acc_train:.2f}%"
          f"\nValid Loss: {loss_val:.4f}, Valid Top-5 Acc: {top5acc_val:.2f}%, Valid Top-10 Acc: {top10acc_val:.2f}%"
          f" Valid BLEU-4: {bleu4_val:.4f}\n")

    # Save model
    save_checkpoint(epoch, epochs_since_improvement, encoder, decoder, encoder_optimizer,
                    decoder_optimizer, bleu4_val, is_best)
    print('-' *150)

#@title Generate Caption for an Image

def generate_image_caption(encoder, decoder, image_path, word_map, beam_size=5):
    """
    Takes in an image and captions it
    """
    k = beam_size

    img = np.array(Image.open(image_path).convert('RGB'))
    img = cv2.resize(img, (256, 256))

    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    img = transform(img)

    # Encode
    encoder_out = encoder(img.unsqueeze(0).to(device))
    enc_image_size = encoder_out.size(1)
    encoder_dim = encoder_out.size(3)

    # Flatten
    encoder_out = encoder_out.view(1, -1, encoder_dim)
    num_pixels = encoder_out.size(1)

    encoder_out = encoder_out.expand(k, num_pixels, encoder_dim)

    # Initialize top previous words tensor
    top_k_prev_words = torch.tensor([[word_map['<start>']]] * k, dtype=torch.long).to(device)

    # Initialize top sequences tensor
    top_k_seqs = top_k_prev_words

    # Initialize top sequences scores tensor
    top_k_scores = torch.zeros(k, 1).to(device)

    # Initialize top sequences alphas tensor
    top_k_seqs_alpha = torch.ones(k, 1, enc_image_size, enc_image_size).to(device)

    # Initialize lists for sequences and their scores/alphas
    complete_seqs = []
    complete_seqs_scores = []

    # Decode
    step = 1
    h, c = decoder.init_hidden_state(encoder_out)

    while True:
        embeddings = decoder.embedding(top_k_prev_words).squeeze(1)
        attention_weighted_encoding, alpha = decoder.attention(encoder_out, h)

        gate = F.sigmoid(decoder.f_beta(h))
        attention_weighted_encoding = gate * attention_weighted_encoding

        h, c = decoder.decode_step(
            torch.cat([embeddings, attention_weighted_encoding], dim=1), (h, c))

        scores = decoder.fc(h)
        scores = F.log_softmax(scores, dim=1)
        scores = top_k_scores.expand_as(scores) + scores

        if step == 1:
            top_k_scores, top_k_words = scores[0].topk(k, 0, True, True)
        else:
            top_k_scores, top_k_words = scores.view(-1).topk(k, 0, True, True)

        prev_word_inds = top_k_words // vocab_size
        next_word_inds = top_k_words % vocab_size

        top_k_seqs = torch.cat([top_k_seqs[prev_word_inds], next_word_inds.unsqueeze(1)], dim=1)

        incomplete_inds = [ind for ind, next_word in enumerate(next_word_inds)
                            if next_word != word_map['<end>']]
        complete_inds = list(set(range(len(next_word_inds))) - set(incomplete_inds))

        if len(complete_inds) > 0:
            complete_seqs.extend(top_k_seqs[complete_inds].tolist())
            complete_seqs_scores.extend(top_k_scores[complete_inds])
        k -= len(complete_inds)

        if k == 0:
            break

        top_k_seqs = top_k_seqs[incomplete_inds]
        h = h[prev_word_inds[incomplete_inds]]
        c = c[prev_word_inds[incomplete_inds]]
        top_k_scores = top_k_scores[incomplete_inds].unsqueeze(1)
        top_k_prev_words = next_word_inds[incomplete_inds].unsqueeze(1)

        if step > 50:
            break
        step += 1

    i = complete_seqs_scores.index(max(complete_seqs_scores))
    seq = complete_seqs[i]

    caption = [id2word[ind] for ind in seq]

    img = Image.open(image_path).convert('RGB')
    print(' '.join(caption[1:-1]))
    plt.axis('off')
    plt.imshow(img)


image_url = 'https://t4.ftcdn.net/jpg/03/12/86/67/360_F_312866728_hTb0ks4uM9aM8hAHItFK46zAEDzPhsTE.jpg' #@param {type:"string"}
beam_size =  5 #@param {type: "number"}

checkpoint = torch.load('/content/drive/MyDrive/Projects/ImageCaptioning/test/image_captioning_best.pth', map_location=device)

encoder = checkpoint['encoder']
decoder = checkpoint['decoder']

vocab_size = len(word2id)
image_path = 'picture.png'

generate_image_caption(encoder, decoder, image_path, word2id, beam_size)